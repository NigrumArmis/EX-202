﻿Активності XP
Екстремальне програмування описує чотири базові активності що виконуються при розробці програмного забезпечення:
- написання коду,
- тестування, 
- слухання, 
- дизайн.

Тестування (Testing - випробування) - дослідження реакцій системи на різні події.

Слухання (Listening) - взаємодія з замовником, розуміння "бізнес-логіки", яку він хоче одержати від програми (проєкту). 
Розвиток даної активності відомий як "гра у планування".

Дизайн (Designing, дослівно - розроблення) - організація (реорганізація) проєкту (коду) з метою покращення його якості (чистоти) -- рефакторинг










﻿Extreme Programming (XP) - Екстремальне програмування
Вступ.
Управління програмними проєктами. Управління проєктами - наука (з присудженням наукових ступенів у галузі технічних наук).
 - управління ресурсами
  = логістика / складське управління
  = фінансово / бюджетне управління
  = HR - людські ресурси
 - управління часом
 - управління знаннями (проєкту)

 Методології управління.
  - "водоспадна" модель
  - "водовирна" модель

Лінійна, жорстка, "водоспадна", класична модель - набір задач, які вирішуються одна за одною (послідовно) з можливістю окремих задач виконувати паралельно.
Головний візуальний інструмент - діаграма Ґанта

---------------------------------------------------------------> час
Складання ТЗ
------------хх
			Проєктування UI
			---------------==
			Проєктування API
			-------------------------
						Тестування UI
						----------------
							Тестування API
							--------------------

Переваги: наочність, прогнозованість, керованість (у кожен момент часу зрозуміло, що має бути завершено, що у процесі, ...)
Недоліки: наявність критичного шляху (певні етапи є критичними і збільшення часу на них збільшує тривалість всього проєкту з можливим "простоєм" інших задач),
довгий час "готової" для показу версії, складність внесення змін (після затвердження ТЗ)

Гнучки, Agile, водовирні, ітеративні, спіральні - моделі управління з постійним повторення однотипних ітерацій (спринтів).
Планування - Проєктування - Випробування - Впровадження
У спіральних моделях мається на увазі, що кожна наступна ітерація більший масштаб
Головний візуальний інструмент - SCRUM-дошка

Екстремальне програмування - різновид гнучких моделей спірального типу, який спрямовано на "абсолютизацію" окремих моментів, 
особливо тих, що протирічать один одному, наприклад, 
максимально швидкий перший випуск --- нормований робочий графік (день/тиждень)
Головна мета - якість коду, що завжди відкритий до доповнення, вдосконалення, внесення змін та зберігає свою керованість.










﻿Основні прийоми XP
Дванадцять основних прийомів екстремального програмування (за першим виданням книги Extreme programming explained) можуть бути об'єднані в чотири групи:
	- короткий цикл зворотного зв'язку (Fine scale feedback)
		= розробка через тестування (Test driven development)
		= гра в планування (Planning game)
		= замовник завжди поруч (Whole team, Onsite customer)
		= парне програмування (Pair programming)

Парне програмування (Pair programming)
Техніка створення ПЗ за якої два програмісти працюють за одним ПК.
Один створює (набирає) код, інший спостерігає. Ролі періодично змінюються.
------------- обговорення -------------
"+" - розподіл навантаження
	- інтелектуальна допомога
	- можливість порадитись, поділитись досвідом
"-" - ускладнення роботи через відмінності стилів
	- різні погляди на вирішення проблеми
	- сповільнення процесу
	- удорожченя процесу ?
	- конкуренція / суперечки
------------- з огляду на професіоналізм ------------- 
- ускладнення роботи через відмінності стилів
	- стандарт кодування -- вимагає один синтаксичний підхід
	- метафора системи -- "стандарт вираження" - підхід до сенсу іменування

	Наприклад, об'єкт для комунікації з API (передача запиту, прийом відповіді)
	метафора: як назвати -- host / node / api / http / commmunicator
			! api-node
	стандарт кодування: як записати -- api_node, API_NODE, apiNode, ApiNode, api-node, refApiNode, constRefApiNode, _apiNode, __apiNode
			! apiNode
	приклад використання: response = apiNode.get('/back/user?login=user')
- різні погляди на вирішення проблеми 
	- теза про максимальне пришвидшення (випуску готового коду)
		- обирається той з підходів, що швидше призводить до розв'язку. + неодмінність подальшого рефакторингу, тобто покращення будуть, але пізніше.

- сповільнення процесу / удорожчення процесу ?
	- є можливість відпочинку (зміни характеру роботи)










﻿Рефакторінг - внесення змін у код, які не змінюють функціональність (поведінку) коду.
Можна вважати поліморфізмом, так як зміни відбуваються із постійною алгоритмічною суттю.
Якщо зміни вносяться в алгоритм роботи, то це не рефакторинг.
Мета: знайти найбільш оптимальну форму вираження коду.
    for(i:1..10) print(i)
    while(i<10) print(i++)
    do print(i++) while(i<10)
    рекурсія
    range(10).forEach(print)
    print(range(10).join(','))
    print(1),print(2),...print(10)
    print("1,2,3...10")
питання оптимальності є відкритим, тобто перед рефакторингом слід це питання вирішити
У XP це - простота (Simple design) - зрозумілість (всередині команди). (+ стандарти кодування, + метафора системи)

Основні прийоми рефакторингу
Можна виділити окремі прийоми, але 
    - не всі можливості рефакторингу будуть реалізовані (перебрані)
    - багато прийомів мають протилежні значення (перенесення поля до батька/до нащадка)
    - прийом прадигмо-орієнтовані (сильно залежать від парадигми, частіше - ООП)

Боротьба з антипатернами
    - "Магічне число" - поява у коді числа (окрім 0 та 1), сенс якого незрозумілий
       (або неочевидний)                який сенс?
       int getRating() {
            return numberOfLateDeliveries > 5 ? 2 :1;
       }
    - "Магічний рядок" - те ж саме, але рядком, різновид "Hardcoded string"
        if(login == "admin") { - "Магічний рядок"
            print("Hello") - Hardcoded string
        }
    - Це ж стосується і кольорів, поява імені чи коду кольору теж можна віднести до цих антипатернів

Можливі рішення:
    - "Магічне число":
        = Enum
            + для обмежених переліків: рейтинг
            - для неперервних даних: кількість протермінованих замовлень
        = константи
            + іменування, розкриття сенсу (через ім'я)
            - зміни вимагають перекомпіляції
        = Функція/метод
            + можливе для складних алгоритмів обчислення
        = Конфігурація (в окремому файлі)
            + можливість змін без перекомпіляції
            - можливість втрат через видалення файлу
        = Провайдери-інжектори (інжекція залежностей)
            + рекомендований підхід в ООП
            - ускладнення архітектури (додавання інжекторів)
        = Ресурси (окремі файли, які автоматично підключаються системою в залежності від умов/оточення запуску програми - ОС, мова, роздільна здатність, розмір/орієнтація екрану тощо)
            + автоматичні зміни, підходить для "Hardcoded string"
            - потреба різних ресурсів для різних умов оточення

Проблема: "роздутий" код (метод, клас, файл тощо)
Ознака(критерій): окремий блок коду можна поєднати своїм коментарем

class{
  method{
    instruction              |
    instruction      | algo      |
    instruction      | for      |  region
    instruction      | smthn      |  for
    instruction      |        |  smthn
    instruction              |
  }                    |
  method{                  |
    instruction              |
    instruction              |
    instruction              |
  }                    |
  method{
    instruction
    instruction
    instruction
  }
}

Альтернативні критерії: блок коду (метод, клас, файл) 
не влазить на один "екран" (25-40 рядків)

Критика: занадто розгалужений код, для розуміння цілісної картини
необхідно переглянути велику кількість файлів










﻿TDD - Test Driven Development - розробка, керована тестами
Ідея - тести з'являються раніше, ніж сама програма.
Тести можна вважати "технічно уточненими ТЗ"
Чому? Тести, що їх написано після складання програми, часто є формальними і підтверджують загальну працездатність модулів програми.
Тоді яе TDD - це вимога, виконання якої має призвести до появи правильно працюючого коду.

Т.З.: Розробити калькулятор римських чисел
Мета: цзагальнити поняття "число", усвідомити роль тестів у проєкті.

Типова помилка - намагатись "додумати" і зробити краще, ніж просто задовольнити наявні тести. У стилі XP це не вітається.
Зворотня задача - скласти "нормальні" тести - вимагає достатньо великого набору тверджень, на стільки, що правильний алгоритм буде коротшим за switch.
В ідеалі використовувати змінні (випадкові) значення.